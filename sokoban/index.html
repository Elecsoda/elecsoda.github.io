<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>推箱子游戏 - 可撤回 + 自定义地图</title>
  <style>
    /* —— 基本样式 —— */
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background-color: #f4f4f9;
      font-family: Arial, sans-serif;
      /* 避免出现水平滚动条 */
      overflow-x: hidden;
    }
    h1 {
      margin: 20px 0;
    }

    /* —— 按钮区域 —— */
    #controls {
      margin-bottom: 10px;
    }
    button {
      margin: 5px;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
    }

    /* —— 自定义地图输入区域，初始隐藏 —— */
    #custom-map-container {
      display: none; 
      margin-bottom: 10px;
    }
    #map-input {
      width: 90%;
      height: 200px;
      margin: 10px auto;
      display: block;
      font-family: monospace; /* 保持字符对齐 */
    }

    /*
      —— 游戏区域 —— 
      设为 80vw 宽，不到最大宽度 900px 时自适应，
      避免一般情况下出现滚动条。
    */
    #game-board {
      width: 80vw;          /* 占屏幕80%宽度 */
      max-width: 900px;     /* 最大宽度，可根据需求调整 */
      margin: 20px auto;    /* 居中 */
      display: grid;
      gap: 1px;             /* 网格间隙 */
      background-color: #bbb;
    }
    /* 每个网格保持正方形，需要现代浏览器支持 */
    .tile {
      aspect-ratio: 1 / 1;
      background-color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-sizing: border-box;
      font-size: 12px; /* 仅用于调试文字 */
    }

    /* —— 墙壁 (#) —— */
    .wall {
      background-color: #333;
      color: #fff;
    }
    /* —— 墙外空地 (_) —— */
    .outside {
      background-color: #e0e0e0;
      color: #aaa;
    }
    /* —— 普通空地 (-) —— */
    .floor {
      background-color: #fff;
    }
    /* —— 目标点（红点） —— */
    .goal::before {
      content: "";
      display: block;
      position: absolute;
      top: 10; left: 10;
      width: 50%; height: 50%;
      background-color: red;
      border-radius: 50%;
      opacity: 0.6;
      z-index: 0; /* 在底层，让箱子/玩家叠在上方 */
    }
    /* —— 玩家（小人） —— */
    .player {
      background-image: url('human.png');
      background-size: cover;
      background-position: center;
      z-index: 1;
    }
    /* —— 箱子 —— */
    .box {
      background-image: url('box.png');
      background-size: cover;
      background-position: center;
      z-index: 1;
    }
    /* —— 箱子叠在目标点上 —— */
    .box-on-goal {
      background-image: url('wall.png');
      background-size: cover;
      background-position: center;
      background-color: #b30000; /* 深红叠加 */
      border-radius: 4px;
      z-index: 1;
    }
    /* —— 状态文本 —— */
    #status {
      font-size: 16px;
      color: #333;
      min-height: 24px; 
      margin: 10px auto;
    }
  </style>
</head>
<body>
  <h1>推箱子游戏</h1>

  <!-- 按钮区域（关卡 + 自定义地图 + 撤回） -->
  <div id="controls">
    <button id="btn-level1">关卡1</button>
    <button id="btn-level2">关卡2</button>
    <button id="btn-level3">关卡3</button>
    <button id="btn-level4">关卡4</button>
    <button id="btn-level5">关卡5</button>
    <button id="btn-level6">关卡6</button>
    <button id="btn-show-custom-map">自定义地图</button>
    <button id="btn-undo">撤回到上一步</button>
  </div>

  <!-- 自定义地图输入区（初始隐藏） -->
  <div id="custom-map-container">
    <textarea id="map-input" placeholder="在此粘贴或输入地图"></textarea>
    <button id="btn-load-map">加载地图</button>
  </div>

  <!-- 游戏区和状态提示 -->
  <div id="game-board"></div>
  <p id="status"></p>

<script>
/* 
  使用“双层地图”：
    floorMap[y][x]: 记录 (#, _, -, .)
    objMap[y][x]:   记录 (@, $, 或 ' ')
  当地图出现'*' => 目标点上有箱子 => floorMap='.', objMap='$'.
  胜利后禁止继续移动，但可以允许“撤回”。
  撤回功能：记录每次移动前后的状态，点击“撤回到上一步”时回到上一次状态。
*/

/** —— 6 个内置关卡 —— */
const level1Text = [
"######",
"#---.#",
"#-$$.#",
"#-$@.#",
"######"
].join("\n");

const level2Text = [
"#####-",
"#..-#-",
"#-@$##",
"#-$--#",
"##---#",
"-#####"
].join("\n");

const level3Text = [
"######",
"#----#",
"#-$@.#",
"#-#$.#",
"#-$-.#",
"######"
].join("\n");

const level4Text = [
"-######-",
"-#.---#-",
"##*#.-#-",
"#--$-$##",
"#--*.$-#",
"#-$-@-.#",
"########"
].join("\n");

const level5Text = [
"____#####__________",
"____#---#__________",
"____#$--#__________",
"__###--$##_________",
"__#--$-$-#_________",
"###-#-##-#___######",
"#---#-##-#####--..#",
"#-$--$----------..#",
"#####-###-#@##--..#",
"____#-----#########",
"____#######________"
].join("\n");

const level6Text = [
"############__",
"#..--#-----###",
"#..--#-$--$--#",
"#..--#$####--#",
"#..----@-##--#",
"#..--#-#--$-##",
"######-##$-$-#",
"__#-$--$-$-$-#",
"__#----#-----#",
"__############"
].join("\n");

/** —— 全局数据 —— */
let floorMap = [];  
let objMap   = [];  
let rows = 0, cols = 0;  
let playerX = 0, playerY = 0;  
let gameWon = false; // 若胜利，则禁止移动

/** 
 * 撤回栈，用于记录每次有效移动。
 * 每次移动时保存：{ playerOldX, playerOldY, playerNewX, playerNewY, boxOldX, boxOldY, boxNewX, boxNewY }
 * 若本次移动没有推箱子，则 boxOldX = boxOldY = boxNewX = boxNewY = null
 */
let undoStack = [];

/**
 * 从文本加载关卡并解析成 floorMap + objMap
 * @param {string} mapText 多行字符串
 */
function loadLevelFromText(mapText) {
  gameWon = false;
  undoStack = []; // 清空撤回栈
  const lines = mapText.replace(/\r/g, "").split("\n");
  rows = lines.length;
  cols = lines[0] ? lines[0].length : 0;

  floorMap = [];
  objMap   = [];
  playerX  = -1;
  playerY  = -1;

  for (let y = 0; y < rows; y++) {
    floorMap[y] = [];
    objMap[y]   = [];
    const line = lines[y] || "";
    for (let x = 0; x < cols; x++) {
      const ch = line[x] || " ";

      // 解析底层与上层
      if (ch === '#') {
        floorMap[y][x] = '#';  
        objMap[y][x]   = ' ';
      } else if (ch === '_') {
        floorMap[y][x] = '_';  
        objMap[y][x]   = ' ';
      } else if (ch === '.') {
        floorMap[y][x] = '.';  
        objMap[y][x]   = ' ';
      } else if (ch === '-') {
        floorMap[y][x] = '-';  
        objMap[y][x]   = ' ';
      } else if (ch === '@') {
        floorMap[y][x] = '-';  
        objMap[y][x]   = '@';
        if (playerX < 0) {
          playerX = x;
          playerY = y;
        }
      } else if (ch === '$') {
        floorMap[y][x] = '-'; 
        objMap[y][x]   = '$';
      } else if (ch === '*') {
        // 初始箱子在目标点上
        floorMap[y][x] = '.'; 
        objMap[y][x]   = '$';
      } else {
        // 其余视为空地
        floorMap[y][x] = '-';
        objMap[y][x]   = ' ';
      }
    }
  }

  // 设置游戏区域“网格行/列”
  const board = document.getElementById("game-board");
  board.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  board.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

  drawBoard();
}

/** 绘制地图（依次渲染 floorMap + objMap） */
function drawBoard() {
  const board = document.getElementById("game-board");
  board.innerHTML = "";

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const tile = document.createElement("div");
      tile.classList.add("tile");

      const fch = floorMap[y][x];  // 底层字符
      const och = objMap[y][x];    // 上层字符

      // —— 渲染底层 —— //
      if (fch === '#') {
        tile.classList.add("wall");
      } else if (fch === '_') {
        tile.classList.add("outside");
      } else if (fch === '-') {
        tile.classList.add("floor");
      } else if (fch === '.') {
        tile.classList.add("goal"); // 红点
      }

      // —— 渲染上层 —— //
      if (och === '@') {
        tile.classList.add("player");
      } else if (och === '$') {
        // 如果底层是 '.' => 箱子叠在目标点上
        if (fch === '.') {
          tile.classList.add("box-on-goal");
        } else {
          tile.classList.add("box");
        }
      }

      board.appendChild(tile);
    }
  }

  checkWin();
}

/** 检查是否所有箱子都在目标点：如果 objMap 中无 '$'，则胜利 */
function checkWin() {
  let foundBox = false;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (objMap[y][x] === '$') {
        foundBox = true;
        break;
      }
    }
    if (foundBox) break;
  }
  const statusEl = document.getElementById("status");
  if (!foundBox) {
    statusEl.textContent = "恭喜，所有箱子已推到目标点！(可按撤回返回上一步)";
    gameWon = true; // 禁止继续移动 (但可选择是否允许撤回)
  } else {
    statusEl.textContent = "";
  }
}

/** 移动玩家 (dx, dy) */
function movePlayer(dx, dy) {
  if (gameWon) return; // 已胜利，不可再移动（若不想允许撤回，可也在撤回里加判断）

  const newX = playerX + dx;
  const newY = playerY + dy;

  // 越界检查
  if (newY < 0 || newY >= rows || newX < 0 || newX >= cols) return;

  // 如果底层是墙(#)或墙外(_)，则无法走
  const floorChar = floorMap[newY][newX];
  if (floorChar === '#' || floorChar === '_') return;

  // 查看上层是否有箱子
  const targetObj = objMap[newY][newX];
  
  // 准备记录本次移动信息
  let moveRecord = {
    playerOldX: playerX,
    playerOldY: playerY,
    playerNewX: playerX,
    playerNewY: playerY,
    boxOldX: null,
    boxOldY: null,
    boxNewX: null,
    boxNewY: null
  };

  if (targetObj === ' ') {
    // 无箱子 -> 直接走
    objMap[playerY][playerX] = ' ';
    objMap[newY][newX]       = '@';
    // 更新玩家坐标
    moveRecord.playerNewX = newX;
    moveRecord.playerNewY = newY;
    playerX = newX;
    playerY = newY;

    // 压入撤回栈
    undoStack.push(moveRecord);

  } else if (targetObj === '$') {
    // 推箱子
    const boxNextX = newX + dx;
    const boxNextY = newY + dy;
    // 越界/墙/另一箱子 -> 推不动
    if (boxNextY < 0 || boxNextY >= rows || boxNextX < 0 || boxNextX >= cols) return;
    if (floorMap[boxNextY][boxNextX] === '#' || floorMap[boxNextY][boxNextX] === '_') return;
    if (objMap[boxNextY][boxNextX] === '$' || objMap[boxNextY][boxNextX] === '@') return;

    // 可以推
    objMap[playerY][playerX] = ' ';  // 玩家离开
    objMap[newY][newX]       = '@';  // 玩家到箱子原位置
    objMap[boxNextY][boxNextX] = '$';// 箱子前进

    // 记录玩家新坐标
    moveRecord.playerNewX = newX;
    moveRecord.playerNewY = newY;
    // 记录箱子的前后位置
    moveRecord.boxOldX = newX;
    moveRecord.boxOldY = newY;
    moveRecord.boxNewX = boxNextX;
    moveRecord.boxNewY = boxNextY;

    // 更新玩家坐标
    playerX = newX;
    playerY = newY;

    // 压入撤回栈
    undoStack.push(moveRecord);
  }

  drawBoard();
}

/** 撤回到上一步：从撤回栈中取出最后一条记录，反向还原 */
function undoMove() {
  if (undoStack.length === 0) return; // 无法撤回

  const lastMove = undoStack.pop();
  // 还原玩家位置
  objMap[lastMove.playerNewY][lastMove.playerNewX] = ' ';
  objMap[lastMove.playerOldY][lastMove.playerOldX] = '@';
  playerX = lastMove.playerOldX;
  playerY = lastMove.playerOldY;

  // 若本次有推箱子，则还原箱子位置
  if (lastMove.boxOldX !== null) {
    // 当前箱子在 boxNewX, boxNewY
    objMap[lastMove.boxNewY][lastMove.boxNewX] = ' ';
    objMap[lastMove.boxOldY][lastMove.boxOldX] = '$';
  }

  // 撤回后，如原本是胜利状态，也将其取消
  gameWon = false;
  document.getElementById("status").textContent = "";

  drawBoard();
}

/* —— 键盘监听：上下左右 —— */
document.addEventListener("keydown", (e) => {
  switch (e.key) {
    case "ArrowUp":
      movePlayer(0, -1);
      break;
    case "ArrowDown":
      movePlayer(0, 1);
      break;
    case "ArrowLeft":
      movePlayer(-1, 0);
      break;
    case "ArrowRight":
      movePlayer(1, 0);
      break;
    default:
      break;
  }
});

/* —— 6 个内置关卡按钮 —— */
document.getElementById("btn-level1").addEventListener("click", () => {
  loadLevelFromText(level1Text);
});
document.getElementById("btn-level2").addEventListener("click", () => {
  loadLevelFromText(level2Text);
});
document.getElementById("btn-level3").addEventListener("click", () => {
  loadLevelFromText(level3Text);
});
document.getElementById("btn-level4").addEventListener("click", () => {
  loadLevelFromText(level4Text);
});
document.getElementById("btn-level5").addEventListener("click", () => {
  loadLevelFromText(level5Text);
});
document.getElementById("btn-level6").addEventListener("click", () => {
  loadLevelFromText(level6Text);
});

/* —— 自定义地图：点击按钮时展开/收起文本框 —— */
const btnShowCustomMap = document.getElementById("btn-show-custom-map");
const customMapContainer = document.getElementById("custom-map-container");
btnShowCustomMap.addEventListener("click", () => {
  if (customMapContainer.style.display === "none") {
    customMapContainer.style.display = "block";
  } else {
    customMapContainer.style.display = "none";
  }
});

/* —— 从文本框加载地图 —— */
document.getElementById("btn-load-map").addEventListener("click", () => {
  const mapText = document.getElementById("map-input").value;
  if (!mapText.trim()) {
    alert("请先在文本框中输入或粘贴地图！");
    return;
  }
  loadLevelFromText(mapText);
});

/* —— 撤回到上一步 —— */
document.getElementById("btn-undo").addEventListener("click", () => {
  undoMove();
});

// 启动时，默认不加载任何关卡，文本框隐藏；等待用户点击按钮
</script>
</body>
</html>